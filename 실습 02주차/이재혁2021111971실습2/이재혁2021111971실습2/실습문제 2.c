// 2024.03.14
// 실습 02번
// 학점 4.3점이 만점이다. 배열 grades[]에 학생 10명의 학점이 저장되어 있다. 이것을 100점 만점으로 변환하여 scores[]에 저장
// 학점 * 23.25581

#include <stdio.h>

void compute(double*, double*);

int main() {
    double grades[10] = { 0.0, 0.5, 1.0, 1.5, 2.0, 2.8, 3.0, 3.7, 4.2, 4.3 };
    // 학생들의 학점을 종류별로 입력
    double scores[10];
    // 학점을 100점 만점으로 전환하여 입력 할 배열

    compute(grades, scores);

    for (int i = 0; i < 10; i++) {
        printf("학생 %d: %.2f\n", i + 1, scores[i]);
    }

    return 0;
}

void compute(double* arr1, double* arr2) {
    for (int i = 0; i < 10; i++) {
        if (arr1[i] == 4.3) {
            arr2[i] = 100.0;
            // 점수 변환 비율이 소수 2자리까지만 입력했을 때 0.3의 오차 발생
            // 4.3의 학점은 100점 만점이기 때문에 100점으로 무조건 전환
        }

        else {
            arr2[i] = arr1[i] * 23.25581;
        }
    }
}

// 소감
// 컴퓨터의 계산은 오차가 발생할 수 있다는 사실을 다시 확인했습니다.
// 처음 점수 전환비율을 소수 2자리까지만으로 계산을 했더니 4.3전환 기준으로 0.03의 오차가 발생했습니다.
// 소수 5번째 자리 까지는 사용해야 보다 정확한 비율로 계산이 되었습니다.
// 
// 학점 계산 같은 경우는 적은 범위의 수여서 계산하는 소수 자리수를 늘려서 해결했지만
// 더 큰범위의 계산을 할 때 만약 메모리가 숫자의 크기를 전부 담지 못해서 계산 오차가 날 수 있다는 생각이 들었습니다.
// 따라서 선언하는 자료형의 메모리크기를 이해하고 알고 있는 것이 정교한 계산을 위해 필수적이라고 느꼈습니다.